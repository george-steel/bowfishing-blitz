<!DOCTYPE html>
<html>
<head>
<style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
}
#canvas {
    display: block;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
}
h1, h2 {
    text-align: center;
}
</style>

<script type="module">
import init, {GameSystem} from "./bowfishing_blitz.js";



async function run() {
    const bundle_promise = fetch("./asset_bundle.zip").then(r => r.arrayBuffer());
    await init();
    console.log("hello from javascript");
    const bundle_buf = await bundle_promise;
    console.log("loaded bundle", bundle_buf.byteLength);

    let canvas = document.getElementById("canvas");

    let bundle_view = new Uint8Array(bundle_buf);
    let game = await GameSystem.init_from_canvas(canvas, bundle_view);
    console.log("Game initialized");

    let width = canvas.width;
    let height = canvas.height;

    const observer = new ResizeObserver(entries => {
        for (const entry of entries) {
            width = entry.devicePixelContentBoxSize?.[0].inlineSize ||
                    entry.contentBoxSize[0].inlineSize * devicePixelRatio;
            height = entry.devicePixelContentBoxSize?.[0].blockSize ||
                     entry.contentBoxSize[0].blockSize * devicePixelRatio;
            const canvas = entry.target;
            canvas.width = Math.max(1, Math.min(width, 4096));
            canvas.height = Math.max(1, Math.min(height, 4096));
            console.log("resizing canvas", width, height);
            game.resize(width, height); // resize the gbuffers
        }
    });
    try {
        observer.observe(canvas, { box: 'device-pixel-content-box' });
    } catch {
        observer.observe(canvas, { box: 'content-box' });
    }

    let total_x = 0;

    canvas.onmousemove = e => {
        total_x += e.movementX;
        game.on_mouse_move(e.movementX, e.movementY);
    }
    document.onpointerlockchange = e => {
        if (!document.pointerLockElement) {
            game.on_cursor_ungrab();
        }
    }
    document.onpointerlockerror = e => {
        game.on_cursor_ungrab();
    }
    canvas.onclick = e => {
        const shouldGrab = game.on_click();
        if (shouldGrab) {
            const lock_promise = canvas.requestPointerLock();
            if (lock_promise) {
                lock_promise.catch(() => game.on_cursor_ungrab())
            } else {
                game.on_cursor_ungrab();
            }
        }
    }
    document.onkeydown = e => {
        if (e.key == "Escape") {
            document.exitPointerLock();
        } else if (e.key == "m") {
            game.stop_music();
        } else if (e.key == "p") {
            console.log("horiz movement", total_x);
            total_x = 0;
        }
    }
    
    let frame_count = 0;
    let old_frame_time = performance.now();

    console.log("registered events")

    function frame() {
        if (++frame_count >= 600) {
            const new_time = performance.now();
            const fps = 600 * 1000 / (new_time - old_frame_time);
            console.log("FPS:", fps);
            old_frame_time = new_time;
            frame_count = 0;
        }
        const result = game.on_frame();
        if (result.need_resize) {
            console.log("need resize");
            game.resize(width, height);
        }
        if (result.should_release_cursor) {
            document.exitPointerLock();
        }
        requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
}

if (navigator.gpu) {
    run();
} else {
    document.body.innerHTML = "<h1>WebGPU Not Supported</h1><h2>Please use a browser such as Chrome or Firefox Nightly that supports WebGPU</h2>";
}
</script>

</script>
</head>
<body>
<canvas id="canvas" width="800" height="600"></canvas>
</body>
</html>